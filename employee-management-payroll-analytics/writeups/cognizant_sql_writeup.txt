In this project I applied my SQL skills to solve real workplace-style data problems in a clear and practical way. I began by designing a structured schema with departments, employees, salary, and attendance tables, keeping relationships and constraints in mind so data stays consistent. Understanding the schema first saved time and reduced mistakes when I started writing queries.

With the schema ready, I populated the database with realistic sample records and then focused on writing SQL that answers typical business questions. I used SELECT with JOINs to combine tables correctly—picking INNER or LEFT joins based on whether missing matches were acceptable. Aggregate functions like COUNT, SUM, and AVG helped me produce useful summaries such as headcount per department and average payroll cost. To handle more specific business logic I used GROUP BY, HAVING, and subqueries; for example, isolating employees with attendance above a threshold and checking their salary records to mark bonus eligibility.

I also paid attention to performance and readability. Instead of `SELECT *`, I picked only required columns and used derived tables or CTEs to make complex queries easier to follow. When queries got long, I split logic into smaller CTEs which made debugging simple. For date-based calculations and monthly reports I used built-in date functions to filter the correct period.

Overall, building this project reinforced how SQL supports decision-making: extract clean data, combine it correctly, and compute summaries that stakeholders can act on. The hands-on experience improved my ability to design schemas, write efficient queries, and explain results—skills that directly map to work at Cognizant where accurate data handling and clear reporting are essential.
